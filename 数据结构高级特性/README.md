# 数据结构高级特性

![avatar](数据结构高级特性.png)

### 1. 切片

##### 1.1 [x:y] :  返回从x到y-1的切片对象

```
>>> L = list(range(100))
>>> L[0:5]
[0, 1, 2, 3, 4]
```
> 注意：L[0:5]表示：从索引0开始取，直到索引5为止，但不包括索引5。

- 如果第一个索引是0，还可以省略：
    ```
    >>> L[:3]
    [0, 1, 2]
    ```
- 支持 负数 切片
    ```
    >>> L[-2:]
    [98, 99]
    >>> L[-2:0]
    []
    >>> L[-2:1]
    []
    >>> L[-2:-1]
    [98]
    >>> L[0:-98]
    [0, 1]
    ```

##### 1.2 [:] : 切取全部元素
```
>>> L[:]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
```

##### 1.3 [x:y:n] : 从x到y-1，每n个取一个制作切片
```
>>> L[0:20:2]
[0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
>>> L[0:20:-2]
[]
>>> L[0:20:-1]
[]
>>> L[0:-20:-1]
[]
>>> L[0:-20:10]
[0, 10, 20, 30, 40, 50, 60, 70]
>>> L[-1:-20:2]
[]
>>> L[-1:-20:-2]
[99, 97, 95, 93, 91, 89, 87, 85, 83, 81]
```
L[n1:n2:n3] ：

>n1代表开始元素下标,不写就是从头，这个要看n3的符号，n3是负的，那就是从最右边，正，从最左边。

>n2代表结束元素下标，不写就是到结束，同上

>n3代表切片间隔以及切片方向,不写就是默认1 ，如-2 表示：切片从后往前，间隔为2

>L中每个元素都有正负两种下标，正数从L[0]开始，表示第一个元素。倒数L[-1]表示倒数第一个元素。L[0]和L[-100]指的同一个元素都是0

>无论L[0]还是L[-100] ，我觉得可以这么理解：你先把负数转换成正数。

>比如：L[0:-2:2]  表示：从index=0的元素，到第（10-2）即index=8的元素。正切片，每隔2个。

### 2.迭代

- list 迭代
    ```
    >>> L = list(range(3))
    >>> L
    [0, 1, 2]
    >>> for n in L:
    ...     print(n)
    ... 
    0
    1
    2
    >>> 
    ```
    如果要对list实现类似Java那样的下标循环,可以用enumerate函数把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身
    ```
    >>> for i, value in enumerate(L):
    ...     print(i, value)
    ... 
    0 0
    1 1
    2 2
    ```


- dict 迭代

    ```
    >>> d = {'a': 1, 'b': 2, 'c': 3}
    >>> d
    {'a': 1, 'b': 2, 'c': 3}
    >>> for k in d:
    ...     print(k)
    ... 
    a
    b
    c
    >>> for k,v in d.items():
    ...     print(k,v)
    ... 
    a 1
    b 2
    c 3
    ```
    > dict的存储不是按照list的方式顺序排列，所以，迭代出的结果顺序很可能不一样。

- 通过collections模块的Iterable判断一个对象是可迭代

    ```
    >>> from collections import Iterable
    >>> isinstance(L, Iterable)
    True
    >>> isinstance(d, Iterable)
    True
    ```
    
